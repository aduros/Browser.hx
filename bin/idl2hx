#!/usr/bin/env perl
#
# Forked from JSX's extern generator and adapted to Haxe
# https://github.com/jsx/JSX
#
# Copyright (c) 2012 DeNA Co., Ltd.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
# associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute,
# sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all copies or substantial
# portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
# NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
# OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use 5.10.0;
use strict;
#use warnings FATAL => 'all';
use warnings;
use Fatal qw(open);
use Data::Dumper;
use File::Basename qw(dirname);
use Storable qw(lock_retrieve lock_store);
use constant WIDTH => 68;

# see http://dev.w3.org/2006/webapi/WebIDL/

my @files = @ARGV;

# Known fake classes that aren't marked as such in specs
my %fake = (
    DocumentEvent => 1,
    DOMLocator => 1,
    DOMConfiguration => 1,
    TypeInfo => 1,
    AbstractView => 1,
    DocumentView => 1,
    EventTarget => 1,
    XMLHttpRequestEventTarget => 1,
);

my %skip = (
    EventListener => 1,
    MediaQueryListener => 1,
    DOMErrorHandler => 1,
    UserDataHandler => 1,
    MutationCallback => 1,
    FileCallback => 1,
    FrameRequestCallback => 1,

    Example => 1,
    Function => 1,
);

# NOTE: JSX's int is signed 32 bit integer

my %typemap = (
    'DOMObject' => 'Dynamic',
    'DOMUserData' => 'Dynamic',
    'DOMString' => 'String',

    'DOMTimeStamp'=> 'Float',
    'octet' => 'Int',
    'byte'  => 'Int',
    'short' => 'Int',
    'long'  => 'Int',
    'long long' => 'Float',
    'unsigned byte' => 'Int',
    'unsigned short' => 'Int',
    'unsigned int' => 'Int',
    'unsigned long' => 'Int',
    'unsigned long long' => 'Float',
    'float' => 'Float',
    'double' => 'Float',
    'unrestricted float'  => 'Float',
    'unrestricted double' => 'Float',

    'object' => 'Dynamic',
    'Object' => 'Dynamic',
    'any' => 'Dynamic',

    # Haxe additions
    'boolean' => 'Bool',
    'void' => 'Void',

    'TimerHandler' => 'Void -> Void',

    'WindowProxy' => 'Window',

    # # http://www.w3.org/TR/dom/
    'MutationCallback' => 'Array<MutationRecord> -> MutationObserver -> Void',

    # # http://dev.w3.org/html5/spec/single-page.html
    'TextTrackMode' => 'String', # enum

    # TODO(bruno): Parse "callback" sections and turn them into the right function type. While still
    # generating an interface/typedef ideally.
    'EventListener' => 'Event -> Void',

    # # http://www.w3.org/TR/cssom-view/
    'MediaQueryListListener' => 'MediaQueryList -> Void',

    # # http://www.w3.org/TR/websockets/
    'Function?' => 'Event -> Void',
    'Function' => 'Event -> Void',

    # # http://www.w3.org/TR/XMLHttpRequest/
    'XMLHttpRequestResponseType' => 'String', # enum

    # # http://www.w3.org/TR/DOM-Level-3-Core/idl-definitions.html
    'UserDataHandler' => 'Int -> String -> Dynamic -> Node -> Node -> Void',

    # # http://dev.w3.org/2009/dap/file-system/file-dir-sys.html
    'FileCallback' => 'File -> Void',

    # # http://html5.org/specs/dom-parsing.html#insertadjacenthtml()
    'SupportedType' => 'String', # enum
    'insertAdjacentHTMLPosition' => 'String', # enum

    # # http://www.w3.org/TR/animation-timing/
    'FrameRequestCallback' => 'Float -> Void',
);

my %haxe_keywords = (
    "callback" => 1,
    "default" => 1,
    "continue" => 1,
);

sub info {
    state $count = 0;
    print STDERR sprintf("[%03d] ", $count++), join(" ", @_), "\n";
}

my $rx_multiword_types = join("|", map { quotemeta($_) }
    'unsigned long long',
    'unsigned byte',
    'unsigned short',
    'unsigned int',
    'unsigned long',

    'long long',

    'unrestricted float',
    'unrestricted double',
);

my $rx_simple_type = qr{
    (?:
        \b
        (?: \w+ :: )? # optional namespace
        (?: (?:$rx_multiword_types) | \w+)
        (?: < [^>]+ > )? # type parameter
    )
}xms;

my $rx_type_modifier = qr{
    (?:
        \? # nullable
        |
        \[ \s* \] # array
        |
        \.\.\. # vararg
    )
}xms;
my $rx_type = qr{
    (?:
        (?:
            # union type
            \(
                \s*
                $rx_simple_type $rx_type_modifier?
                (?: \s+ or \s+ $rx_simple_type $rx_type_modifier? )+
                \s*
            \)
        )
        |
        $rx_simple_type
    )
    $rx_type_modifier?
}xms;

my $rx_params = qr{
    (?: $rx_type | [^\(\)]+ )*
}xms;

my $rx_comments = qr{
    (?: // [^\n]*? \n | /\* .*? \*/ \n? )
}xms;

my %classdef;

sub parse_idls {
    my @files = @_;

    foreach my $file(@files) {
        info "parsing $file";

        # XXX: spec bug?
        my $Document_is_HTMLDocument = ($file =~ / \b html5 \b/xms);

        local $typemap{Document} = "HTMLDocument" if $Document_is_HTMLDocument;

        my $content = do {
            my $arg = $file;
            if($arg =~ /^https?:/) {
                if($arg =~ /\.idl$/) {
                    $arg = "curl -L $arg 2>/dev/null |";
                }
                else {
                    $arg = "w3m -dump $arg |";
                }
            }
            open my($fh), $arg; # magic open!
            local $/;
            <$fh>;
        };

        # typedef
        while($content =~ m{
                ^ \s* \b typedef \b
                \s+
                (?<existing_type> $rx_simple_type)
                \s+
                (?<new_type> \w+) \s*
                ;
            }xmsg) {

            ($typemap{$+{new_type}} = to_hx_type($+{existing_type})) =~ s/$rx_comments//xms;
        }

        # class definition
        while($content =~ m{
                    (?<attrs> (?: \[ (?: [^\]]+ | \[ \s* \])+ \] \s+)* )
                    (?<type> (?:partial \s+)? interface | exception | dictionary)
                    \s+ (?<name> \w+)
                    (?: \s* : \s* (?<base> [\w:]+) )?
                    \s*
                    \{ (?<members> [^\}]*? ) \}
                    \s* ;
                }xmsg) {

            my $class   = $+{name};
            my $attrs   = $+{attrs};
            my $type    = $+{type};
            my $base    = $+{base};
            my $members = $+{members};
            my $partial = ($type =~ /\bpartial\b/xms) || ($attrs =~ /\b Supplemental \b/xms);

            if($Document_is_HTMLDocument && $class eq 'Document') {
                $type =~ s/partial \s+//xms;
                $class = "HTMLDocument";
                $base  = "Document";
                $partial = 0;
            }

            info $type, $class, ($base ? ": $base" : ());

            my $def = $classdef{$class} //= {
                attrs => $attrs,
                name  => $class,
                implements => [],
                members => [],
                decl    => {},
                fake    => $fake{$class},
            };

            if(not $partial) {
                $def->{file} = $file;
            }

            $def->{base} //= $base if $base;
            $def->{skip} = 1 if $skip{$class};

            my $members_ref = $def->{members};

            # name to array of members; to resolve override
            my $decl_ref = $def->{decl};

            if($attrs) {
                while($attrs =~ m{
                    \b Constructor \s* (?: \(
                        (?<params> $rx_params)
                    \) )?
                }xmsg) {
                    make_functions(
                        $decl_ref, $members_ref,
                        "new",
                        "Void", $+{params});
                }

                if($attrs =~ /\b NoInterfaceObject \b/xms) {
                    $def->{fake} = 1;
                }
            }

            while($members =~ m{
                    (?<comments> $rx_comments)
                    |
                    (?<spaces> \s+)
                    |
                    (?<member> [^;]+;
                        (?: \s+ | (?<member_comment> $rx_comments* ) \n)
                    )
                }xmsg) {
                if($+{spaces}) {
                    push @{$members_ref}, "" if $+{spaces} =~ /\n/;
                    next;
                }

                if(my $comments = $+{comments}) {
                    chomp $comments;
                    push @{$members_ref}, $comments;
                    next;
                }

                my $member = $+{member};

                push @{$members_ref}, $+{member_comment} if $+{member_comment};

                # compress extra spaces
                $member =~ s{\s+}{ }g;

                # member constant
                if($member =~ m{
                        \b const \s+ (?<type> $rx_type) \s+ (?<ident> \w+) \s+=\s+ (?<value> .*)
                        [^;\(\)]*;
                    }xms) {
                    my $id = $+{ident};

                    my $type = to_hx_type($+{type});
                    my $value = $+{value};

                    # WebIDL's constants are available both as class members
                    # and instance members
                    # But Haxe doesn't support that, so use only the static const
                    my $static_const = "static inline var $id : $type = $value;";

                    $decl_ref->{$id} //= [];
                    push @{$decl_ref->{$id}}, $static_const;
                    push @{$members_ref}, {
                        id => $id,
                        decl => $static_const,
                        type => $type,
                        static => 1,
                    };
                }
                # member var
                elsif($member =~ m{
                        (?: \bstringifier\b \s+ )?
                        (?<readonly> \breadonly\b \s+)?
                        (?: \battribute\b \s+)?
                        (?: \[ [^\]]+ \])?
                        (?<type> $rx_type) \s+ (?<ident> \w+)
                        (?: \s+ setraises\( [^\)]+ \) )?
                        [^;\(\)]* ;
                    }xms) {

                    my $id = $+{ident};

                    my $decl = "var $id";
                    if($+{readonly}) {
                        $decl .= "(default,null)"
                    }
                    my $type = to_hx_type($+{type});

                    $decl .= " : $type;";

                    $decl_ref->{$id} //= [];
                    push @{$decl_ref->{$id}}, $decl;
                    push @{$members_ref}, {
                        id   => $id,
                        decl => $decl,
                        type => $type,
                        static => 0,
                    };
                }
                # member function
                elsif($member =~ m{
                        (?<property>
                            (?: (?: stringifier | legacycaller | getter | setter | creator | deleter) \s+ )*
                        )
                        (?<static> \b static \b \s+)?
                        (?<ret_type> $rx_type)
                        \s+
                        (?<ident> \w*)
                        \s*
                        \(
                            (?<params> $rx_params)
                        \)
                        (?: \s* raises \s* \( $rx_params \) )?
                        ;
                    }xms) { # member function

                    my $id       = $+{ident};
                    my $prop     = trim($+{property});
                    my $static   = $+{static};
                    my $ret_type = $+{ret_type};
                    my $params   = $+{params};

                    my $ret_type_may_be_undefined = 0;

                    # Some getters omit the "getter" keyword, so look for de facto standard names
                    if ($params) {
                        my $type = to_hx_type($ret_type, 0);
                        if($id eq "item" or index($prop, "getter") >= 0) {
                            $def->{array_access} = $type;
                            next;
                        } elsif($id eq "namedItem") {
                            $def->{dynamic_access} = $type;
                            next;
                        }
                    }

                    if($prop) {
                        if(!$id) {
                            # no name
                            next;
                        }
                        push @{$members_ref}, "/* $prop */";
                    }
                    elsif(!$id) {
                        die "unexpected no name for $member.\n";
                    }
                    make_functions(
                        $decl_ref, $members_ref,
                        $id,
                        $ret_type, $params,
                        $ret_type_may_be_undefined, $static);
                }
                elsif($member =~ m{stringifier;}) {
                    # ignore
                }
                else {
                    die "[BUG] cannot parse member: $member\n";
                }
            }
        }

        # implements interfaces
        info 'process implements';
        {
            my $classes = join "|", keys %classdef;
            while($content =~ m{
                ^ \s* (?<class> $classes)
                \s+ implements
                \s+ (?<interface> $classes)
                \s* ;
                }xmsg) {
                my $def       = $classdef{$+{class}};
                my $interface = $classdef{$+{interface}};

                info "$def->{name} implements $interface->{name}";

                # FIXME
                push @{ $def->{members} },
                    "",
                    "// implements $interface->{name}",
                    @{$interface->{members}};

                $interface->{skip} = 1;
                $interface->{fake} = 1;
            }
        }
    }
}

sub generate_haxe {
    my($fh, @idls) = @_;

    info 'output';

    my %idl_map;
    foreach my $idl(@idls) {
        $idl_map{$idl} = 1;
    }

    foreach my $def(values %classdef) {
        if($def->{skip} or $def->{done}) {
            next;
        }
        if (not (exists $def->{file})) {
            next; # This def was only ever partially defined, never output it
        }
        if (not $idl_map{$def->{file}}) {
            next; # Not part of this module
        }

        my %seen;

        my $classdecl = "\@:native(\"$def->{name}\") extern class $def->{name}";

        my @interfaces = ();
        if($def->{base}) {
            push(@interfaces, " extends $def->{base}");
        }
        if(exists $def->{array_access}) {
            push(@interfaces, " implements ArrayAccess<" . $def->{array_access} . ">");
        }
        # if(exists $def->{dynamic_access}) {
        #     push(@interfaces, " implements Dynamic<" . $def->{dynamic_access} . ">");
        # }
        $classdecl .= join(",", @interfaces);

        my $comment = "From $def->{file}";
        if ($def->{fake}) {
            $comment .= "\n * NOTE: This is a fake class, and is not available at run-time.";
        }
        say $fh "/** $comment */\n", $classdecl, " {";

        my @members = @{$def->{members}};

        # trim
        pop(@members)   while @members && $members[-1] !~ /\S/;
        shift(@members) while @members && $members[ 0] !~ /\S/;

        if(@members) {
            my $in_whitespace = 1;
            foreach my $member(@members) {
                my $s;

                if(ref $member) { # var or func
                    my $is_func = exists $member->{param_types};

                    $s = $member->{decl};

                    # For fields that use Haxe keywords, the best we can do is emit them commented out
                    if (exists $haxe_keywords{$member->{id}}) {
                        say $fh "\t", "// Excluded because \"$member->{id}\" is a Haxe keyword:";
                        say $fh "\t", "// $s";
                        next;
                    }

                    # FIXME(bruno): If a method *overloads* something in its base class, it won't be
                    # emitted
                    if(my @m = find_member_from_bases($def, $member->{id})) {
                        # Ignore all member/method overrides
                        next;
                    }

                    if($is_func) {
                        next if $seen{$member->{id}}++;
                        # Look for other methods that this one overloads
                        foreach my $other(@members) {
                            if (ref $other and $member != $other and
                                    exists $other->{param_types} and $member->{id} eq $other->{id}) {
                                ++$seen{$other->{id}};
                                $s = "\@:overload( $other->{anonymous_decl} {})\n$s";
                            }
                        }

                        # prettify if needed
                        # if(length $s > WIDTH) {
                        #     $s =~ s/ \( (.+) \) /prettify_params($1)/xmse;
                        # }
                    }
                    else {
                        # skip if it is already defined
                        next if $seen{ join(";", $member->{id}, $member->{static}) }++;
                    }
                    $in_whitespace = 0;
                }
                else { # comments, etc.
                    # $s = $member;
                    next if $in_whitespace;
                    $s = "";
                    $in_whitespace = 1;
                }

                $s =~ s/^/\t/xmsg;
                $s =~ s/\s+\z//xmsg;
                say $fh $s;
            }

            say $fh "}";
        }
        else {
            say $fh "}";
        }

        say $fh "";
    }
}

sub to_hx_type {
    my($idl_type, $may_be_undefined) = @_;
    $idl_type = trim($idl_type);

    my $original = $idl_type;

    $idl_type =~ s/.+://; # remove namespace

    my $array;
    if($idl_type =~ s{\A sequence < (.+?) >  }{$1}xms) {
        $array = 1;
    }
    elsif($idl_type =~ s{\A Maybe< (.+?) >  }{$1}xms) { # defined in idl2hx/extra/*.idl
        $may_be_undefined = 1;
    }

    $idl_type  =~ s{
        (?:
            (?<array> \[ \s* \] )
            |
            (?<vararg> \.\.\. )
            |
            (?<nullable> \? )
        )*
        \z
    }{}xms;
    my $vararg   = $+{vararg} // ""; # not used yet
    my $nullable = $+{nullable} // "";
    $array //= $+{array};

    my $type;
    if(my $t = $typemap{$idl_type}) {
        $t = "Null<$t>" if $nullable;
        $type = $t;
        if($array) {
            $type = "Array<$type>"
        }
        # $type .= "/*$original*/";
    }
    else {
        my $t = $idl_type;
        $t = "Null<$t>" if $nullable;
        $type = $t;
        if($array) {
            $type = "Array<$type>"
        }
    }

    if($may_be_undefined) {
        return "Null<$type>";
    }
    else {
        return $type;
    }
}

sub make_functions {
    my($decl_ref, $members_ref, $name, $ret_type, $src_params, $ret_type_may_be_undefined, $static) = @_;

    my $ret_type_decl = defined($ret_type)
        ? " : " . to_hx_type($ret_type, $ret_type_may_be_undefined)
        : "";

    my @unresolved_params;
    foreach my $param(split /,/, $src_params // "") {
        $param =~ m{
            (?:
                (?: \b (?: in | (?<optional> optional)) \b \s+ )*
                (?<type> $rx_type) \s+
                (?<ident> \w+)
            )
        }xms or die "Cannot parse line:  '$src_params'\n";

        my $ident = $+{ident};
        $ident .= "_" if exists $haxe_keywords{$ident};

        my %t = (
            name => $ident,
            type => $+{type},
            optional => !!$+{optional},
        );

        $t{name} = "?$t{name}" if $t{optional};

        # FIXME: support varargs
        $t{optional} = 1 if $t{type} =~ /\.\.\. \z/xms;

        push @unresolved_params, \%t;
    }

    my @decls;
    my @funcs;

    foreach my $params_ref(resolve_overload(@unresolved_params)) {
        # resolve optional args
        my @d;
        my @f;
        # while(1) {
            my $p = join ", ", map {
                "$_->{name} : $_->{hx_type}"
            } @{$params_ref};

            my $f = "function $name(";
            if ($p) {
                $f .= " $p ";
            }
            $f .= ")$ret_type_decl;";
            if($static) {
                $f = "static $f";
            }

            unshift @d, $f;
            unshift @f, {
                id            => $name,
                decl          => $f,
                anonymous_decl => "function( $p )$ret_type_decl",
                param_types   => [ map { $_->{hx_type} } @{$params_ref} ],
                ret_type_decl => $ret_type_decl,
                static        => $static ? 1 : 0,
            };

            # my $last = pop @{$params_ref};
            # if(not defined $last or not $last->{optional}) {
            #     last;
            # }
        # }
        push @decls, @d;
        push @funcs, @f;
    }

    $decl_ref->{$name} //= [];
    push @{$decl_ref->{$name}}, @decls;
    push @{$members_ref},       @funcs;

    return;
}

sub resolve_overload {
    my @params = @_;

    my @o;
    if(@params) {
        my $head = shift @params;

        my $type = $head->{type};
        if($type =~ / \( (.+) \) /xms) {
            $type = $1;
        }

        my @types = split /\b or \b/xms, $type;

        # parameter "int" also accepts "number"
        # if(grep { to_hx_type($_) =~ /\A int \[\]/xms } @types) {
        #     push @types, "number[]";
        # }

        my @resolved = resolve_overload(@params);
        foreach my $t(@types) {
            my $p = {
                type     => $t,
                hx_type => to_hx_type($t),
                name     => $head->{name},
                optional => $head->{optional},
            };
            push @o, map { [ $p, @{$_} ] } @resolved;
        }
    }
    else {
        push @o, \@params;
    }

    return @o;
}

sub find_member_from_bases {
    my($def, $id) = @_;

    return if $id eq 'new';

    my @m;
    my $base = $def->{base};

    while($base && exists $classdef{$base}) {
        $def = $classdef{$base};
        if($def->{decl}{$id}) {
            push @m, @{$def->{decl}{$id}};
        }

        $base = $def->{base};
    }

    return @m;
}

sub prettify_params {
    my($params) = @_;

    my $p = join ",\n", map { trim($_) } split /,/, $params;
    $p =~ s/^/\t/xmsg;
    return "(\n$p\n)";
}

sub function_params {
    my($decl) = @_;

    my($params) = $decl =~ /\( (.*) \)/xms;

    # remove names
    $params =~ s/\w+ \s* :/:/xmsg;

    # remove spaces
    $params =~ s/\s+//xmsg;

    return $params;
}

sub trim {
    my($s) = @_;
    $s =~ s/\A \s+//xms;
    $s =~ s/\s+ \z//xms;
    return $s;
}

return 1;
